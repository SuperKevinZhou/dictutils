# Production Readiness Review

## 1. Mock and placeholder data sources

- Test utilities keep generating "mock" dictionaries without ever conforming to a real parser/serializer. [`src/util/test_utils.rs:54-176`](src/util/test_utils.rs:54-176) writes literal headers, static offsets, and stub metadata for MDict/StarDict/ZIM, so almost every unit/integration test only exercises the code paths that succeed on this contrived layout.
- The two flagship examples build fake dictionaries from scratch with hard-coded headers and indexes, which explains why they never fail even though they do not reflect any real MDX/Stardict/ZIM data layout. See [`examples/basic_dict_loading.rs:239-355`](examples/basic_dict_loading.rs:239-355) and [`examples/dict_search_operations.rs:282-355`](examples/dict_search_operations.rs:282-355).
- As a result, the tests and examples conspire to give false confidence: they never open or validate a legitimate dictionary file, they only assert that the mock files can be created and read through the stubbed APIs.

## 2. Security and correctness gaps that need engineering work

### 2.1 Bounds / offset validation ✅

- `MDict::read_entry_at_offset` now validates each `offset`/`length` window via `validate_entry_window`, guarding against overflow and ensuring reads stay within the actual file size (`[`src/dict/mdict.rs:734-809`](src/dict/mdict.rs:734-809)).

### 2.2 Index persistence mismatch ✅

- `MDict::build_indexes`, `StarDict::build_indexes`, and `ZimDict::build_indexes` now persist real on-disk offsets, and the shared B-Tree implementation enforces 8-byte offsets when rebuilding sidecars (`[`src/dict/mdict.rs:838-871`](src/dict/mdict.rs:838-871), [`src/dict/stardict.rs:1142-1164`](src/dict/stardict.rs:1142-1164), [`src/dict/zimdict.rs:791-815`](src/dict/zimdict.rs:791-815), [`src/index/btree.rs:332-365`](src/index/btree.rs:332-365)).

### 2.3 Compression helpers expose panic vectors and coarse errors

- LZ4 decompression blindly calls `lz4_flex::decompress` with the naïve guess `compressed.len() * 4`, which panics when the real decompressed size exceeds the estimate or when the compressed frame uses streaming metadata (`[`src/util/compression.rs:94-105`](src/util/compression.rs:94-105)).
- All compressors map their I/O or corruption failures to `DictError::DecompressionError`, which conflates genuinely corrupted frames with legitimate I/O issues and makes upstream handling impossible (`[`src/util/compression.rs:78-123`](src/util/compression.rs:78-123)).

### 2.4 CLI output is unsanitized

- The CLI helpers print dictionary metadata and stats directly to the terminal without escaping or sanitizing the strings. Malicious dictionaries can inject escape sequences, so we cannot safely expose these utilities until every field is checked (`[`src/lib.rs:138-244`](src/lib.rs:138-244)).

## 3. Testing and documentation do not trigger the risky paths

- No existing test fixture loads an authentic MDX/StarDict/ZIM file; all fixtures are generated by the placeholders covered above, so the tests never visit the real parsing routines nor the more complicated error paths (`[`src/util/test_utils.rs:54-176`](src/util/test_utils.rs:54-176)).
- The examples encourage users to rely on the fake builders, reinforcing the false belief that the current parsers understand the formats (`[`examples/basic_dict_loading.rs:239-355`](examples/basic_dict_loading.rs:239-355) and [`examples/dict_search_operations.rs:282-355`](examples/dict_search_operations.rs:282-355)).

## Summary and next steps

Until these mock data generators are replaced by real format support, strict bounds checking is added, compression helpers consume on-disk metadata, and CLI output is sanitized, releasing this crate beyond experimental/prototype status will lead to corrupted files, panics, or security risks. The README now reflects that state, but engineering effort must replace every mock/stub path before production readiness can be claimed.
